{"version":3,"file":"drag.min.js","sources":["../src/utils.ts","../src/Dragger.ts","../src/drag.ts"],"sourcesContent":["import { Client, Position } from \"./types\";\nimport { IArrayFormat } from \"@daybrush/utils\";\n\nexport function getPinchDragPosition(clients: Client[], prevClients: Client[], startClients: Client[]) {\n    const nowCenter = getAverageClient(clients);\n    const prevCenter = getAverageClient(prevClients);\n    const startCenter = getAverageClient(startClients);\n    const pinchClient = getAddClient(startClients[0], getMinusClient(nowCenter, startCenter));\n    const pinchPrevClient = getAddClient(startClients[0], getMinusClient(prevCenter, startCenter));\n\n    return getPosition(pinchClient, pinchPrevClient, startClients[0]);\n}\nexport function isMultiTouch(e: any): boolean {\n    return e.touches && e.touches.length >= 2;\n}\nexport function getPositionEvent(e: any): Client[] {\n    if (e.touches) {\n        return getClients(e.touches);\n    } else {\n        return [getClient(e)];\n    }\n}\nexport function getPosition(client: Client, prevClient: Client, startClient: Client): Position {\n    const { clientX, clientY } = client;\n    const {\n        clientX: prevX,\n        clientY: prevY,\n    } = prevClient;\n\n    const {\n        clientX: startX,\n        clientY: startY,\n    } = startClient;\n    const deltaX = clientX - prevX;\n    const deltaY = clientY - prevY;\n    const distX = clientX - startX;\n    const distY = clientY - startY;\n\n    return {\n        clientX,\n        clientY,\n        deltaX,\n        deltaY,\n        distX,\n        distY,\n    };\n}\nexport function getDist(clients: Client[]) {\n    return Math.sqrt(\n        Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2)\n    );\n}\nexport function getPositions(clients: Client[], prevClients: Client[], startClients: Client[]): Position[] {\n    return clients.map((client, i) => getPosition(client, prevClients[i], startClients[i]));\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n    const length = Math.min(touches.length, 2);\n    const clients = [];\n\n    for (let i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nexport function getAverageClient(clients: Client[]) {\n    return {\n        clientX: (clients[0].clientX + clients[1].clientX) / 2,\n        clientY: (clients[0].clientY + clients[1].clientY) / 2,\n    };\n}\nexport function getAddClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX + client2.clientX),\n        clientY: (client1.clientY + client2.clientY),\n    };\n}\n\nexport function getMinusClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX - client2.clientX),\n        clientY: (client1.clientY - client2.clientY),\n    };\n}\n","import { DragOptions, Client, Position } from \"./types\";\nimport {\n    getPositionEvent, getPosition, getClients, getPositions,\n    isMultiTouch, getPinchDragPosition, getAverageClient, getDist,\n} from \"./utils\";\nimport { addEvent, removeEvent } from \"@daybrush/utils\";\nimport { start } from \"repl\";\n\nexport default class Dragger {\n    public options: DragOptions = {};\n    private flag = false;\n    private pinchFlag = false;\n    private datas = {};\n    private isDrag = false;\n    private isPinch = false;\n    private isMouse = false;\n    private isTouch = false;\n    private prevClients: Client[] = [];\n    private startClients: Client[] = [];\n\n    constructor(private el: Element, options: DragOptions = {}) {\n        this.options = {\n            container: el,\n            preventRightClick: true,\n            events: [\"touch\", \"mouse\"],\n            ...options,\n        };\n\n        const { container, events } = this.options;\n\n        this.isTouch = events!.indexOf(\"touch\") > -1;\n        this.isMouse = events!.indexOf(\"mouse\") > -1;\n\n        if (this.isMouse) {\n            addEvent(el, \"mousedown\", this.onDragStart);\n            addEvent(container!, \"mousemove\", this.onDrag);\n            addEvent(container!, \"mouseup\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            addEvent(el, \"touchstart\", this.onDragStart);\n            addEvent(container!, \"touchmove\", this.onDrag);\n            addEvent(container!, \"touchend\", this.onDragEnd);\n        }\n    }\n    public isDragging() {\n        return this.isDrag;\n    }\n    public isPinching() {\n        return this.isPinch;\n    }\n    public onDragStart = (e: any) => {\n        if (!this.flag && e.cancelable === false) {\n            return;\n        }\n        if (!this.isDrag && isMultiTouch(e) && !this.pinchFlag) {\n            this.onPinchStart(e);\n        }\n        if (this.flag) {\n            return;\n        }\n        const clients = this.startClients[0] ? this.startClients : getPositionEvent(e);\n\n        this.flag = true;\n        this.isDrag = false;\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.datas = {};\n\n        const position = getPosition(clients[0], this.prevClients[0], this.startClients[0]);\n\n        const {\n            dragstart,\n            preventRightClick,\n        } = this.options;\n\n        if (\n            (preventRightClick && e.which === 3)\n            || (dragstart && dragstart({\n                datas: this.datas,\n                inputEvent: e,\n                ...position,\n            })) === false) {\n            this.flag = false;\n        }\n        this.flag && e.preventDefault();\n    }\n    public onDrag = (e: any) => {\n        if (!this.flag) {\n            return;\n        }\n        const clients = getPositionEvent(e);\n\n        if (this.pinchFlag) {\n            this.onPinch(e, clients);\n        }\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const position: Position = this.pinchFlag\n            ? getPinchDragPosition(clients, prevClients, startClients)\n            : getPosition(clients[0], prevClients[0], startClients[0]);\n\n        if (!position.deltaX && !position.deltaY) {\n            return;\n        }\n        this.isDrag = true;\n\n        const drag = this.options.drag;\n        drag && drag({\n            datas: this.datas,\n            ...position,\n            inputEvent: e,\n        });\n        this.prevClients = clients;\n    }\n    public onDragEnd = (e: any) => {\n        if (!this.flag) {\n            return;\n        }\n        if (this.pinchFlag) {\n            this.onPinchEnd(e);\n        }\n        this.flag = false;\n\n        const dragend = this.options.dragend;\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n\n        const position: Position = this.pinchFlag\n            ? getPinchDragPosition(prevClients, prevClients, startClients)\n            : getPosition(prevClients[0], prevClients[0], startClients[0]);\n\n        this.startClients = [];\n        this.prevClients = [];\n        dragend && dragend({\n            datas: this.datas,\n            isDrag: this.isDrag,\n            inputEvent: e,\n            ...position,\n        });\n    }\n    public onPinchStart(e: TouchEvent) {\n        if (!this.flag) {\n            return;\n        }\n        this.pinchFlag = true;\n\n        const pinchstart = this.options.pinchstart;\n\n        const pinchClients = getClients(e.changedTouches);\n\n        this.startClients.push(...pinchClients);\n        this.prevClients.push(...pinchClients);\n\n        if (!pinchstart) {\n            return;\n        }\n        const startClients = this.startClients;\n        const startAverageClient = getAverageClient(startClients);\n        const centerPosition = getPosition(\n            startAverageClient,\n            startAverageClient,\n            startAverageClient,\n        );\n        pinchstart({\n            datas: this.datas,\n            touches: getPositions(startClients, startClients, startClients),\n            ...centerPosition,\n            inputEvent: e,\n        });\n    }\n    public onPinch(e: TouchEvent, clients: Client[]) {\n        if (!this.flag || !this.pinchFlag) {\n            return;\n        }\n        this.isPinch = true;\n\n        const pinch = this.options.pinch;\n        if (!pinch) {\n            return;\n        }\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const centerPosition = getPosition(\n            getAverageClient(clients),\n            getAverageClient(prevClients),\n            getAverageClient(startClients),\n        );\n        const distance = getDist(clients);\n        const startDistance = getDist(startClients);\n        pinch({\n            datas: this.datas,\n            touches: getPositions(clients, prevClients, startClients),\n            scale: distance / startDistance,\n            distance,\n            ...centerPosition,\n            inputEvent: e,\n        });\n    }\n    public onPinchEnd(e: TouchEvent) {\n        if (!this.flag || !this.pinchFlag) {\n            return;\n        }\n        const isPinch = this.isPinch;\n\n        this.isPinch = false;\n        this.pinchFlag = false;\n        const pinchend = this.options.pinchend;\n\n        if (!pinchend) {\n            return;\n        }\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const centerPosition = getPosition(\n            getAverageClient(prevClients),\n            getAverageClient(prevClients),\n            getAverageClient(startClients),\n        );\n        pinchend({\n            datas: this.datas,\n            isPinch,\n            touches: getPositions(prevClients, prevClients, startClients),\n            ...centerPosition,\n            inputEvent: e,\n        });\n        this.isPinch = false;\n        this.pinchFlag = false;\n    }\n    public unset() {\n        const el = this.el;\n        const container = this.options.container!;\n\n        if (this.isMouse) {\n            removeEvent(el, \"mousedown\", this.onDragStart);\n            removeEvent(container as any, \"mousemove\", this.onDrag);\n            removeEvent(container as any, \"mouseup\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            removeEvent(el, \"touchstart\", this.onDragStart);\n            removeEvent(container as any, \"touchmove\", this.onDrag);\n            removeEvent(container as any, \"touchend\", this.onDragEnd);\n        }\n    }\n}\n","import Dragger from \"./Dragger\";\nimport { DragOptions } from \"./types\";\n\nexport default function setDrag(el: Element, options: DragOptions) {\n    return new Dragger(el, options);\n}\n"],"names":["getPinchDragPosition","clients","prevClients","startClients","nowCenter","getAverageClient","prevCenter","startCenter","getPosition","getAddClient","getMinusClient","getPositionEvent","e","touches","getClients","getClient","client","prevClient","startClient","clientX","clientY","deltaX","deltaY","distX","distY","getDist","Math","sqrt","pow","getPositions","map","i","length","min","push","client1","client2","el","options","_this","flag","cancelable","isDrag","isMultiTouch","pinchFlag","onPinchStart","datas","position","_a","dragstart","which","inputEvent","preventDefault","onPinch","drag","onPinchEnd","dragend","container","preventRightClick","events","isTouch","indexOf","isMouse","this","addEvent","onDragStart","onDrag","onDragEnd","isPinch","pinchstart","pinchClients","changedTouches","_b","startAverageClient","centerPosition","pinch","distance","startDistance","scale","pinchend","removeEvent","Dragger"],"mappings":"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"}